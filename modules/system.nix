# SPDX-FileCopyrightText:  2021 Richard Brežák and NixNG contributors
#
# SPDX-License-Identifier: MPL-2.0
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

{ pkgs, lib, nglib, config, ... }:
with lib; with nglib;
let
  cfg = config.system;

  configFinal = config;
in
{
  options.system = {
    createNixRegistration = mkEnableOption
      ''
        Create $out/registration, which allows one to create and populate
        the Nix database at start up, useful when building container images,
        which must be able to use Nix themselves.
      '';

    build = mkOption {
      default = {};
      description = lib.mdDoc ''
        Attribute set of derivations used to set up the system.
      '';
      type = types.submoduleWith {
        modules = [{
          freeformType = with types; lazyAttrsOf (uniq unspecified);
        }];
      };
    };

    activation = mkDagOption ''
      A set of shell script fragments that are executed when a NixNG system
      configuration is activated. You can update /etc, create accounts, and
      so on. For creating service related directories or file,
      please use <option>init.services.<service>.ensureSomething</option>.
      These fragments are isolated and can't effect each other's environment.
      These are run every time the system configuration is activated, which also
      happens at boot, therefore it's important that these scripts are idempotent
      and fast.
    '';

    activationScript = mkOption {
      description = ''
        Script generated from <option>system.activation</option>, used to setup the environment.
      '';
      type = types.path;
      readOnly = true;
    };

    name = mkOption {
      description = "System name, used when generating container images";
      type = types.str;
    };
  };

  config = {
    system.activation.currentSystem = nglib.dag.dagEntryAnywhere
      ''
        export PATH=${pkgs.busybox}/bin

        mkdir -p /run

        function linkFarm() {
            src="$1"
            dst="$2"

            find "$src" -mindepth 1 -type d -print0 | sed -e "s~$src~~" | xargs -0 -I {} mkdir "$dst/{}"
            find "$src" -mindepth 1 -type f -print0 | sed -e "s~$src~~" | xargs -0 -I {} ln -s "$src/{}" "$dst/{}"
            find "$src" -mindepth 1 -type l -print0 | sed -e "s~$src~~" | xargs -0 -I {} cp "$src/{}" "$dst/{}"
        }
        linkFarm $_system_config /run/current-system

        mkdir -p /run/current-system/sw/bin
        ${concatStringsSep "\n" (map (pkg:
          ''
            execs=$(${pkgs.busybox}/bin/find ${pkg}/bin -type f)
            for exec in $execs; do
              ln -s $exec /run/current-system/sw/bin/$(basename $exec)
              chmod +x /run/current-system/sw/bin/$(basename $exec)
            done
          ''
        ) config.environment.systemPackages)}
      '';

    system.activationScript = pkgs.writeShellScript "activation"
      ''
        ## Set path to the system closure
        ## This is substituted in from `top-level`
        _system_config="@systemConfig@"

        ${mergeShellFragmentsIsolated cfg.activation.result}

        ## _status is set by the shell code generated by `mergeShellFragmentsIsolated`
        exit $_status
      '';

    assertions = [
      {
        assertion = !(cfg.activation ? "cycle" || cfg.activation ? "loops");
        message = ''
          `cfg.activation` has one or more cycles and/or loops.
          - cycles:
            ${(map (x: "{ after = [ ${concatSepStrings " " x.after} ]; data = ${x.data}; name = ${x.name} }") cfg.activation.loops or []) or ""}
          - loops:
            ${(map (x: "{ after = [ ${concatSepStrings " " x.after} ]; data = ${x.data}; name = ${x.name} }") cfg.activation.loops or [])}
        '';
      }
    ];
  };
}
